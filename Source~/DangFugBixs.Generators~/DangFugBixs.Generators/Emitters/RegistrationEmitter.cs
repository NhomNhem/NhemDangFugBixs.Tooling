using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using NhemDangFugBixs.Common.Models;
using NhemDangFugBixs.Generators.Utils;

namespace NhemDangFugBixs.Generators.Emitters;

internal static class RegistrationEmitter {
    public static string GenerateSource(
        IEnumerable<ServiceInfo> services, 
        IEnumerable<SceneInjectionInfo> sceneServices,
        IEnumerable<SceneRegistrationInfo> sceneRegistrations,
        string assemblyName) {
        
        string sanitizedAssembly = assemblyName.Replace(".", "").Replace("-", "");
        
        using var stringWriter = new StringWriter();
        using var writer = new IndentedTextWriter(stringWriter, "    ");
        
        // 1. Header 
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine("// Generated by NhemDangFugBixs.Tooling");
        writer.WriteLine();
        writer.WriteLine("using System;");
        writer.WriteLine("using VContainer;");
        writer.WriteLine("using VContainer.Unity;");
        writer.WriteLine("#if UNITY_5_3_OR_NEWER");
        writer.WriteLine("using UnityEngine;");
        writer.WriteLine("#endif");
        writer.WriteLine();
        
        using (writer.Block($"namespace NhemDangFugBixs.Generated.{sanitizedAssembly}")) {
            
            // 1. Blueprint for Editor Discovery (Scene Injection)
            using (writer.Block("public static class SceneInjectionBlueprint")) {
                writer.WriteLine("public static readonly Type[] ComponentTypes = {");
                writer.Indent++;
                foreach (var svc in sceneServices) {
                    writer.WriteLine($"typeof({svc.FullName}),");
                }
                writer.Indent--;
                writer.WriteLine("};");
            }
            writer.WriteLine();

            // 2. Standard VContainer Registrations
            using (writer.Block("public static class VContainerRegistration")) {
                
                var groups = services.GroupBy(s => s.ScopeName);

                foreach (var group in groups) {
                    string methodName = $"Register{group.Key}"; 
                    
                    using (writer.Block($"public static void {methodName}(IContainerBuilder builder)")) {
                        // 2a. Scene MonoBehaviour registrations (FindFirstObjectByType + RegisterComponent)
                        var sceneRegList = sceneRegistrations.ToList();
                        if (sceneRegList.Count > 0) {
                            writer.WriteLine("#if UNITY_2023_1_OR_NEWER || NHEM_FORCE_FIND_OBJECT");
                            writer.WriteLine("// Scene MonoBehaviours [AutoRegisterScene]");
                            foreach (var reg in sceneRegList) {
                                string varName = $"_{char.ToLower(reg.ClassName[0])}{reg.ClassName.Substring(1)}";
                                writer.WriteLine($"var {varName} = UnityEngine.Object.FindFirstObjectByType<{reg.FullName}>();");
                                writer.WriteLine($"if ({varName} != null) builder.RegisterComponent({varName});");
                            }
                            writer.WriteLine("#endif");
                            writer.WriteLine();
                        }

                        // 2b. Standard service registrations
                        foreach (var svc in group) {
                            var interfaces = svc.InterfaceNames;
                            
                            // VContainer entry point interfaces - handled automatically by AsImplementedInterfaces
                            var entryPointInterfaces = new HashSet<string> {
                                "VContainer.Unity.IInitializable",
                                "VContainer.Unity.ITickable",
                                "VContainer.Unity.IFixedTickable",
                                "VContainer.Unity.ILateTickable",
                                "VContainer.Unity.IStartable",
                                "VContainer.Unity.IPostInitializable",
                                "VContainer.Unity.IPostTickable",
                                "VContainer.Unity.IPostFixedTickable",
                                "VContainer.Unity.IPostLateTickable",
                                "VContainer.Unity.IPostStartable"
                            };
                            
                            bool isEntryPoint = interfaces.Any(i => entryPointInterfaces.Contains(i));

                            if (svc.IsComponent) {
                                writer.WriteLine($"builder.RegisterComponentInHierarchy<{svc.FullName}>();");
                            } else if (isEntryPoint) {
                                // Use Register + AsImplementedInterfaces + AsSelf for entry points
                                // AsImplementedInterfaces registers all interfaces (including ITickable, IInitializable, etc.)
                                // AsSelf ensures the concrete type can still be resolved directly
                                writer.WriteLine($"builder.Register<{svc.FullName}>(Lifetime.{svc.Lifetime}).AsImplementedInterfaces().AsSelf();");
                            } else {
                                if (interfaces.Length > 0) {
                                    string interfaceList = string.Join(", ", interfaces);
                                    writer.WriteLine($"builder.Register<{svc.FullName}>(Lifetime.{svc.Lifetime}).As<{interfaceList}>();");
                                } else {
                                    writer.WriteLine($"builder.Register<{svc.FullName}>(Lifetime.{svc.Lifetime});");
                                }
                            }
                        }
                    }
                    writer.WriteLine();
                }
            }
        }
        return stringWriter.ToString();
    }
}
